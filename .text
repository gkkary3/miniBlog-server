# 🚀 MiniBlog 프로젝트 포트폴리오 분석 보고서

## 📋 프로젝트 개요

**프로젝트명**: MiniBlog  
**목적**: 개인 블로그 플랫폼을 위한 RESTful API 서버  
**개발 기간**: 장기 협업 프로젝트  
**배포 URL**: [https://miniblog-server.onrender.com/api](https://miniblog-server.onrender.com/api)  

### 🎯 핵심 특징
- **완전한 블로그 생태계**: 회원가입부터 게시글 작성, 댓글, 좋아요, 팔로우까지 완전한 소셜 블로그 기능
- **실제 배포 환경**: Render를 통한 실제 서비스 배포
- **소셜 로그인 지원**: Google, Kakao OAuth 통합
- **이메일 인증 시스템**: Gmail SMTP를 통한 실제 이메일 발송
- **AWS S3 파일 업로드**: 실제 클라우드 스토리지 연동

---

## 🛠 기술 스택 및 아키텍처

### **Backend Framework**
- **NestJS**: 모듈식 아키텍처를 통한 확장 가능한 서버 구조
- **TypeScript**: 타입 안전성과 개발 생산성 향상

### **데이터베이스**
- **PostgreSQL**: 관계형 데이터베이스
- **TypeORM**: ORM을 통한 데이터베이스 추상화
- **Supabase**: 클라우드 PostgreSQL 호스팅

### **인증 & 보안**
- **JWT (JSON Web Token)**: Access Token + Refresh Token 구조
- **Passport.js**: 다양한 인증 전략 지원
- **bcrypt**: 비밀번호 해싱
- **OAuth 2.0**: Google, Kakao 소셜 로그인

### **클라우드 서비스**
- **AWS S3**: 이미지 파일 업로드 및 저장
- **Gmail SMTP**: 이메일 인증 발송
- **Render**: 서버 배포 플랫폼

### **개발 도구**
- **Swagger**: API 문서 자동 생성
- **Jest**: 단위 테스트 및 E2E 테스트
- **ESLint + Prettier**: 코드 품질 및 스타일 관리

---

## 🏗 데이터베이스 설계

### **주요 엔티티 구조**

#### 1. **User 엔티티**
```typescript
- id (PK), username, email, userId (unique)
- provider, providerId, profileImage (소셜 로그인용)
- refreshToken (JWT 갱신용)
- 관계: posts[], likedPosts[], comments[], following[], followers[]
```

#### 2. **Post 엔티티**
```typescript
- id (PK), title, content, images[], thumbnail
- userId, username (작성자 정보)
- 관계: user, comments[], likedUsers[], categories[]
```

#### 3. **Comment 엔티티 (대댓글 지원)**
```typescript
- id (PK), content, postId, userId
- parentId (대댓글을 위한 자기참조)
- 관계: post, user, parent, replies[]
```

#### 4. **Category 엔티티**
```typescript
- id (PK), name
- 관계: posts[] (다대다)
```

### **핵심 데이터베이스 기능**
- **CASCADE DELETE**: 사용자 삭제 시 관련 데이터 자동 삭제
- **대댓글 시스템**: 자기참조를 통한 2단계 댓글 구조
- **팔로우 시스템**: 사용자 간 다대다 관계
- **좋아요 시스템**: 게시글과 사용자 간 다대다 관계

---

## 🎨 핵심 구현기능

### 1. **인증 시스템**
#### **로컬 인증**
- 이메일 인증번호 발송 (Gmail SMTP)
- JWT Access Token (1시간) + Refresh Token (7일)
- bcrypt를 통한 안전한 비밀번호 해싱

#### **소셜 로그인**
- **Google OAuth**: Passport Google Strategy 구현
- **Kakao OAuth**: Passport Kakao Strategy 구현
- 소셜 계정 정보 자동 매핑 (프로필 이미지 포함)

### 2. **게시글 관리**
#### **CRUD 기능**
- 게시글 작성/수정/삭제 (권한별 접근 제어)
- 이미지 다중 업로드 (AWS S3)
- 썸네일 설정 기능

#### **고급 검색 기능**
```typescript
// 통합 검색: 제목, 내용, 작성자, 카테고리
// 정렬: 최신순, 좋아요순, 댓글순
// 페이지네이션 지원
```

### 3. **댓글 시스템**
- **대댓글 지원**: `parentId`를 통한 2단계 댓글 구조
- **실시간 댓글 수**: 게시글별 댓글 개수 집계
- **CASCADE DELETE**: 게시글 삭제 시 댓글 자동 삭제

### 4. **소셜 기능**
#### **팔로우 시스템**
- 사용자 간 팔로우/언팔로우
- 팔로워/팔로잉 목록 조회
- 팔로우 상태 확인 API

#### **좋아요 시스템**
- 게시글 좋아요/취소
- 좋아요 개수 실시간 집계
- 좋아요 누른 사용자 목록

### 5. **파일 업로드**
- **AWS S3 연동**: 실제 클라우드 스토리지 사용
- **파일 검증**: 이미지 타입, 크기 제한 (5MB)
- **UUID 파일명**: 파일명 충돌 방지

---

## 🚀 개발 과정에서의 기술적 도전과 해결

### 1. **JWT 보안 강화**
**문제**: Access Token만 사용 시 보안 취약점  
**해결**: Refresh Token 패턴 도입
```typescript
// Access Token (1시간) + Refresh Token (7일)
// Refresh Token은 DB에 저장하여 무효화 가능
```

### 2. **대댓글 시스템 구현**
**문제**: 무한 중첩 댓글의 복잡성  
**해결**: 2단계로 제한된 자기참조 구조
```typescript
// parentId를 통한 원댓글-대댓글 관계
// 성능과 UX의 균형점 찾기
```

### 3. **소셜 로그인 통합**
**문제**: 여러 OAuth 제공자별 다른 데이터 구조  
**해결**: Passport Strategy 패턴으로 통일
```typescript
// Google, Kakao별 별도 Strategy 구현
// 공통 인터페이스로 데이터 정규화
```

### 4. **파일 업로드 최적화**
**문제**: 로컬 파일 시스템의 한계  
**해결**: AWS S3 직접 업로드 구현
```typescript
// Multer로 메모리 임시 저장 후 S3 업로드
// 환경변수 검증을 통한 안전한 설정 관리
```

### 5. **데이터베이스 마이그레이션 관리**
**문제**: 스키마 변경 시 데이터 무결성  
**해결**: TypeORM 마이그레이션 시스템 활용
```typescript
// 6개의 마이그레이션 파일로 점진적 스키마 업데이트
// CASCADE DELETE 설정으로 참조 무결성 보장
```

### 6. **검색 성능 최적화**
**문제**: 복잡한 통합 검색의 성능 이슈  
**해결**: QueryBuilder를 통한 최적화된 쿼리
```typescript
// ILIKE 연산자로 대소문자 무시 검색
// LEFT JOIN으로 필요한 관계만 로드
// 서브쿼리로 집계 함수 최적화
```

---

## 💻 실제 코드 구현 예시

### 1. **JWT 인증 시스템**

#### **로그인 및 토큰 생성**
```typescript
// src/routes/auth/auth.service.ts
async login(user: UserResponseDto) {
  const payload = {
    id: user.id,
    email: user.email,
    username: user.username,
    userId: user.userId,
  };

  const accessToken = this.jwtService.sign(payload);
  const refreshToken = await this.generateRefreshToken(user.id);

  // Refresh Token을 DB에 저장
  await this.userRepository.update(user.id, { refreshToken });

  return {
    accessToken,
    refreshToken,
  };
}

async generateRefreshToken(userId: number): Promise<string> {
  const payload = { userId, type: 'refresh' };
  return this.jwtService.sign(payload, {
    secret: 'refresh_secret_key', // 별도 시크릿 키 사용
    expiresIn: '7d', // 7일
  });
}
```

#### **소셜 로그인 처리**
```typescript
// 소셜 로그인 통합 처리 로직
async handleSocialLogin(socialUser: any) {
  // 기존 사용자 확인
  let user = await this.userRepository.findOne({
    where: {
      provider: socialUser.provider,
      providerId: socialUser.providerId,
    },
  });

  // 이메일로도 확인
  if (!user) {
    user = await this.userRepository.findOne({
      where: { email: socialUser.email },
    });
  }

  if (user) {
    // 기존 사용자 - 토큰 생성 후 반환
    const payload = {
      id: user.id,
      email: user.email,
      username: user.username,
      userId: user.userId,
    };

    const accessToken = this.jwtService.sign(payload);
    const refreshToken = await this.generateRefreshToken(user.id);

    await this.userRepository.update(user.id, { refreshToken });

    return {
      user: plainToInstance(UserResponseDto, user),
      accessToken,
      refreshToken,
      isNewUser: false,
    };
  } else {
    // 신규 사용자 - 추가 정보 입력 필요
    return {
      isNewUser: true,
      email: socialUser.email,
      provider: socialUser.provider,
      providerId: socialUser.providerId,
      profileImage: socialUser.profileImage,
      tempUsername: socialUser.username,
    };
  }
}
```

### 2. **Google OAuth Strategy**
```typescript
// src/routes/auth/strategies/google.strategy.ts
@Injectable()
export class GoogleStrategy extends PassportStrategy(Strategy, 'google') {
  constructor(private readonly authService: AuthService) {
    super({
      clientID: process.env.GOOGLE_CLIENT_ID || '',
      clientSecret: process.env.GOOGLE_CLIENT_SECRET || '',
      callbackURL: process.env.GOOGLE_CALLBACK_URL || 
        'http://localhost:4000/auth/google/callback',
      scope: ['email', 'profile'],
    });
  }

  async validate(
    accessToken: string,
    refreshToken: string,
    profile: GoogleProfile,
    done: VerifyCallback,
  ): Promise<any> {
    const { name, emails, photos } = profile;
    const user = {
      email: emails[0].value,
      username: `${name.givenName} ${name.familyName}`,
      provider: 'google',
      providerId: profile.id,
      profileImage: photos[0]?.value || undefined,
    };

    // AuthService에서 소셜 로그인 처리
    const result = await this.authService.handleSocialLogin(user);
    done(null, result);
  }
}
```

### 3. **대댓글 시스템**

#### **댓글 엔티티 (자기참조 관계)**
```typescript
// src/entity/comments.entity.ts
@Entity()
export class Comment {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  content: string;

  @Column()
  postId: number;

  @Column()
  userId: number;

  // 대댓글을 위한 부모 댓글 ID
  @Column({ nullable: true })
  parentId: number;

  // 부모 댓글 관계 (대댓글 → 원댓글)
  @ManyToOne(() => Comment, (comment) => comment.replies)
  @JoinColumn({ name: 'parentId' })
  parent: Comment;

  // 자식 댓글들 관계 (원댓글 → 대댓글들)
  @OneToMany(() => Comment, (comment) => comment.parent)
  replies: Comment[];
}
```

#### **대댓글 작성 로직**
```typescript
// src/routes/posts/posts.service.ts
async createComment(id: number, body: CreateCommentDto, userId: number) {
  // 부모 댓글이 지정된 경우 검증
  if (body.parentId) {
    const parentComment = await this.commentRepository.findOneBy({
      id: body.parentId,
    });

    if (!parentComment) {
      throw new HttpException('Parent comment not found', HttpStatus.NOT_FOUND);
    }

    // 부모 댓글이 같은 게시글에 속하는지 확인
    if (parentComment.postId !== id) {
      throw new HttpException(
        'Parent comment does not belong to this post',
        HttpStatus.BAD_REQUEST,
      );
    }

    // 대댓글에 대댓글 방지 (2단계 제한)
    if (parentComment.parentId) {
      throw new HttpException(
        'Cannot reply to a reply',
        HttpStatus.BAD_REQUEST,
      );
    }
  }

  return this.commentRepository.save({ ...body, postId: id, userId });
}
```

### 4. **게시글 검색 시스템**
```typescript
// src/routes/posts/posts.service.ts
async searchPosts(searchDto: SearchPostsDto) {
  const queryBuilder = this.postRepository
    .createQueryBuilder('post')
    .leftJoinAndSelect('post.user', 'user')
    .leftJoinAndSelect('post.categories', 'categories')
    .leftJoinAndSelect('post.likedUsers', 'likedUser')
    .leftJoinAndSelect('post.comments', 'comments');

  // 통합 검색: 제목, 내용, 작성자, 카테고리, 사용자ID
  if (searchDto.search) {
    queryBuilder.andWhere(
      '(post.title ILIKE :search OR post.content ILIKE :search OR post.username ILIKE :search OR categories.name ILIKE :search OR user.userId ILIKE :search)',
      { search: `%${searchDto.search}%` },
    );
  }

  // 정렬 옵션
  if (searchDto.sortBy === SortType.LATEST) {
    queryBuilder.orderBy('post.createdAt', 'DESC');
  } else if (searchDto.sortBy === SortType.LIKES) {
    // 좋아요 수로 정렬 (서브쿼리 사용)
    queryBuilder
      .addSelect((subQuery) => {
        return subQuery
          .select('COUNT(*)')
          .from('post_liked_users_user', 'plu')
          .where('plu."postId" = post.id');
      }, 'likescount')
      .orderBy('likescount', 'DESC');
  } else if (searchDto.sortBy === SortType.COMMENTS) {
    // 댓글 수로 정렬 (서브쿼리 사용)
    queryBuilder
      .addSelect((subQuery) => {
        return subQuery
          .select('COUNT(*)')
          .from('comment', 'c')
          .where('c."postId" = post.id');
      }, 'commentscount')
      .orderBy('commentscount', 'DESC');
  }

  // 페이지네이션
  if (searchDto.page && searchDto.limit) {
    queryBuilder.skip((searchDto.page - 1) * searchDto.limit);
    queryBuilder.take(searchDto.limit);
  }

  const [posts, total] = await queryBuilder.getManyAndCount();

  return {
    posts,
    total,
    page: searchDto.page || 1,
    limit: searchDto.limit || 10,
    totalPages: Math.ceil(total / (searchDto.limit || 10)),
  };
}
```

### 5. **AWS S3 파일 업로드**
```typescript
// src/routes/upload/upload.service.ts
@Injectable()
export class UploadService {
  private s3Client: S3Client | null = null;
  private bucketName: string;
  private isConfigured: boolean = false;

  constructor(private configService: ConfigService) {
    // 환경변수 검증
    const awsRegion = this.configService.get<string>('AWS_REGION');
    const awsAccessKeyId = this.configService.get<string>('AWS_ACCESS_KEY_ID');
    const awsSecretAccessKey = this.configService.get<string>('AWS_SECRET_ACCESS_KEY');
    const awsBucketName = this.configService.get<string>('AWS_S3_BUCKET_NAME');

    if (!awsRegion || !awsAccessKeyId || !awsSecretAccessKey || !awsBucketName) {
      console.warn('⚠️ AWS S3 환경변수가 설정되지 않았습니다.');
      this.isConfigured = false;
      return;
    }

    try {
      this.s3Client = new S3Client({
        region: awsRegion,
        credentials: {
          accessKeyId: awsAccessKeyId,
          secretAccessKey: awsSecretAccessKey,
        },
      });

      this.bucketName = awsBucketName;
      this.isConfigured = true;
      console.log('✅ AWS S3 설정 완료');
    } catch (error) {
      console.error('❌ AWS S3 설정 실패:', error);
      this.isConfigured = false;
    }
  }

  async uploadFile(file: UploadFile): Promise<string> {
    if (!this.isConfigured || !this.s3Client) {
      throw new Error('AWS S3가 설정되지 않았습니다.');
    }

    // UUID로 고유한 파일명 생성
    const fileName = `${uuidv4()}-${file.originalname}`;

    const command = new PutObjectCommand({
      Bucket: this.bucketName,
      Key: fileName,
      Body: file.buffer,
      ContentType: file.mimetype,
    });

    try {
      await this.s3Client.send(command);

      // S3 URL 생성
      const awsRegion = this.configService.get<string>('AWS_REGION');
      const imageUrl = `https://${this.bucketName}.s3.${awsRegion}.amazonaws.com/${fileName}`;

      return imageUrl;
    } catch (error) {
      console.error('S3 업로드 에러:', error);
      throw new Error('파일 업로드에 실패했습니다.');
    }
  }
}
```

### 6. **사용자 엔티티 (팔로우 시스템)**
```typescript
// src/entity/user.entity.ts
@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({ length: 100 })
  username: string;

  @Column({ unique: true })
  email: string;

  @Column({ unique: true })
  userId: string;

  // 소셜 로그인 필드
  @Column({ nullable: true })
  provider: string; // 'local', 'google', 'kakao'

  @Column({ nullable: true })
  providerId: string;

  @Column({ nullable: true })
  profileImage: string;

  // JWT Refresh Token 저장
  @Column({ type: 'varchar', nullable: true, select: false })
  refreshToken: string | null;

  // 팔로우 시스템 (다대다 자기참조)
  @ManyToMany(() => User, (user) => user.followers)
  @JoinTable({
    name: 'user_followers_user',
    joinColumn: {
      name: 'userId_1',
      referencedColumnName: 'id',
    },
    inverseJoinColumn: {
      name: 'userId_2', 
      referencedColumnName: 'id',
    },
  })
  following: User[];

  @ManyToMany(() => User, (user) => user.following)
  followers: User[];

  // 게시글과의 관계
  @OneToMany(() => Post, (post) => post.user, { cascade: true })
  posts: Post[];

  // 좋아요한 게시글
  @ManyToMany(() => Post, (post) => post.likedUsers)
  likedPosts: Post[];

  // 작성한 댓글
  @OneToMany(() => Comment, (comment) => comment.user, { cascade: true })
  comments: Comment[];
}
```

### 7. **이메일 인증 시스템**
```typescript
// src/routes/auth/services/email.service.ts
@Injectable()
export class EmailService {
  private transporter: nodemailer.Transporter;

  constructor() {
    this.transporter = nodemailer.createTransporter({
      service: 'gmail',
      auth: {
        user: process.env.EMAIL_ADDRESS,
        pass: process.env.EMAIL_PASSWORD, // Gmail 앱 비밀번호
      },
    });
  }

  async sendVerificationEmail(email: string, code: string): Promise<void> {
    const mailOptions = {
      from: process.env.EMAIL_ADDRESS,
      to: email,
      subject: '[MiniBlog] 이메일 인증번호',
      html: `
        <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
          <h2>이메일 인증</h2>
          <p>MiniBlog 회원가입을 위한 인증번호입니다.</p>
          <div style="background-color: #f5f5f5; padding: 20px; text-align: center; margin: 20px 0;">
            <h1 style="color: #333; letter-spacing: 5px;">${code}</h1>
          </div>
          <p>인증번호는 5분간 유효합니다.</p>
        </div>
      `,
    };

    try {
      await this.transporter.sendMail(mailOptions);
      console.log(`인증 이메일 발송 완료: ${email}`);
    } catch (error) {
      console.error('이메일 발송 실패:', error);
      throw new Error('이메일 발송에 실패했습니다.');
    }
  }
}
```

---

## 📈 프로젝트 성과 및 학습 내용

### **기술적 성취**
1. **완전한 풀스택 경험**: 백엔드 API부터 실제 배포까지
2. **실무 수준의 인증 시스템**: JWT + OAuth + 이메일 인증
3. **클라우드 서비스 통합**: AWS S3, Gmail SMTP, Render 배포
4. **데이터베이스 설계**: 정규화된 관계형 DB 설계
5. **RESTful API 설계**: 일관된 API 패턴과 문서화

### **도전했던 고급 기능**
- **대댓글 시스템**: 자기참조 관계 설계
- **팔로우 시스템**: 다대다 관계 구현
- **실시간 집계**: 좋아요, 댓글 수 실시간 계산
- **통합 검색**: 다중 테이블 검색 최적화
- **파일 업로드**: 클라우드 스토리지 연동

### **개발 프로세스**
- **TDD 접근**: Jest를 통한 테스트 주도 개발
- **모듈화**: NestJS의 모듈 시스템 활용
- **타입 안전성**: TypeScript 완전 활용
- **문서화**: Swagger를 통한 API 문서 자동화

---

## 🎯 면접 예상 질문 대응

### **🛠 기술 스택 선택 관련**

### **Q: 왜 NestJS를 선택했나요?**
A: NestJS는 TypeScript 기반으로 타입 안정성을 제공하고, 데코레이터를 활용한 모듈식 아키텍처로 확장성이 뛰어납니다. Express 기반이라 성능도 우수하고, Swagger 자동 문서화, 의존성 주입 등 엔터프라이즈급 기능들이 내장되어 있어 선택했습니다.

### **Q: TypeORM vs Prisma, 왜 TypeORM을 선택했나요?**
A: TypeORM은 데코레이터 기반의 엔티티 정의로 NestJS와 완벽하게 통합되고, QueryBuilder를 통한 복잡한 쿼리 작성이 용이합니다. 특히 마이그레이션 관리와 관계 설정이 직관적이어서 선택했습니다. 복잡한 검색 기능과 집계 쿼리를 구현할 때 QueryBuilder의 유연성이 큰 도움이 되었습니다.

### **Q: PostgreSQL을 선택한 이유는?**
A: PostgreSQL은 관계형 데이터베이스 중에서도 JSON 타입 지원, 배열 타입, 풀텍스트 검색 등 NoSQL 기능도 제공합니다. 특히 이 프로젝트에서 게시글의 이미지 배열 저장과 ILIKE 연산자를 통한 대소문자 무시 검색 기능이 필요했는데, PostgreSQL이 최적이었습니다.

---

### **🏗 아키텍처 및 설계 관련**

### **Q: 이 프로젝트에서 가장 어려웠던 부분은?**
A: 대댓글 시스템 구현이 가장 도전적이었습니다. 자기참조 관계에서 발생하는 순환 참조 문제를 해결하기 위해 parentId 필드를 활용한 2단계 구조로 설계했고, TypeORM의 관계 설정을 통해 효율적인 쿼리를 구현했습니다.

### **Q: RESTful API 설계 원칙을 어떻게 적용했나요?**
A: HTTP 메서드별 역할을 명확히 했습니다. GET은 조회, POST는 생성, PUT은 전체 수정, DELETE는 삭제로 구분했고, URL 구조도 `/posts/@userId/:id/comments`처럼 리소스 계층을 명확히 표현했습니다. 상태 코드도 200, 201, 400, 404 등을 적절히 사용했습니다.

### **Q: 모듈 구조는 어떻게 설계했나요?**
A: 기능별로 모듈을 분리했습니다. AuthModule, PostsModule, UserModule, CommentModule, UploadModule로 나누어 각각 독립적인 관심사를 가지도록 했습니다. 공통 기능은 데코레이터나 미들웨어로 분리하여 재사용성을 높였습니다.

### **Q: 에러 처리는 어떻게 했나요?**
A: NestJS의 HttpException을 활용하여 일관된 에러 응답을 제공했습니다. 400(BAD_REQUEST), 404(NOT_FOUND), 401(UNAUTHORIZED) 등 상황에 맞는 HTTP 상태 코드를 사용하고, 클라이언트가 이해할 수 있는 명확한 에러 메시지를 제공했습니다.

---

### **🗄 데이터베이스 설계 및 최적화**

### **Q: 데이터베이스 설계 시 고려사항은?**
A: 관계형 데이터베이스의 정규화 원칙을 따라 엔티티 간 관계를 설계했습니다. 특히 CASCADE DELETE 설정으로 데이터 무결성을 보장하고, 인덱스 최적화를 통해 검색 성능을 향상시켰습니다.

### **Q: 팔로우 시스템의 다대다 관계는 어떻게 구현했나요?**
A: User 엔티티에서 자기참조 다대다 관계를 구현했습니다. `@JoinTable`로 중간 테이블 `user_followers_user`를 명시적으로 정의하고, `following`과 `followers` 양방향 관계를 설정했습니다. 이를 통해 팔로워/팔로잉 목록을 효율적으로 조회할 수 있습니다.

### **Q: 게시글 검색 성능은 어떻게 최적화했나요?**
A: QueryBuilder를 사용해 필요한 관계만 LEFT JOIN으로 로드하고, ILIKE 연산자로 대소문자 무시 검색을 구현했습니다. 좋아요 수나 댓글 수로 정렬할 때는 서브쿼리를 사용해 집계 함수를 최적화했습니다. 또한 페이지네이션으로 불필요한 데이터 로딩을 방지했습니다.

### **Q: 마이그레이션은 어떻게 관리했나요?**
A: TypeORM의 마이그레이션 시스템을 활용하여 6개의 마이그레이션 파일로 점진적으로 스키마를 업데이트했습니다. 각 마이그레이션은 특정 기능 추가나 구조 변경에 대응하며, 버전 관리를 통해 롤백도 가능하도록 구성했습니다.

### **Q: N+1 쿼리 문제는 어떻게 해결했나요?**
A: `relations` 옵션이나 `leftJoinAndSelect`를 사용해 연관 데이터를 한 번에 로드했습니다. 특히 게시글 목록 조회 시 각 게시글마다 작성자 정보를 따로 조회하는 문제였는데, `leftJoinAndSelect`로 한 번에 조회하도록 수정했습니다.

---

### **🔐 보안 관련**

### **Q: JWT 보안을 어떻게 강화했나요?**
A: Access Token의 짧은 만료 시간(1시간)과 Refresh Token(7일)을 분리하여 보안과 사용성의 균형을 맞췄습니다. Refresh Token은 데이터베이스에 저장하여 필요 시 무효화할 수 있도록 했습니다.

### **Q: 비밀번호 보안은 어떻게 처리했나요?**
A: bcrypt 라이브러리를 사용해 솔트를 포함한 해싱을 적용했습니다. 원본 비밀번호는 저장하지 않고, 로그인 시 `compare` 함수로 해시 값을 비교합니다. 또한 User 엔티티에서 `select: false` 옵션으로 패스워드 필드가 기본 조회에서 제외되도록 했습니다.

### **Q: API 인증은 어떻게 구현했나요?**
A: Passport JWT Strategy를 구현하여 토큰 기반 인증을 적용했습니다. `@UseGuards(JwtAuthGuard)` 데코레이터로 인증이 필요한 API를 보호하고, 커스텀 데코레이터 `@UserInfo()`로 현재 사용자 정보를 쉽게 가져올 수 있도록 했습니다.

### **Q: 소셜 로그인의 보안은 어떻게 보장했나요?**
A: OAuth 2.0 표준을 따라 구현했으며, 환경변수로 클라이언트 시크릿을 관리합니다. 소셜 플랫폼에서 받은 정보는 검증 후 사용하고, 기존 계정과의 연동은 이메일 기준으로 안전하게 처리했습니다.

---

### **🚀 성능 최적화**

### **Q: 파일 업로드는 왜 AWS S3를 선택했나요?**
A: 확장성과 안정성을 고려하여 AWS S3를 선택했습니다. 로컬 파일 시스템 대비 무제한 용량, CDN 연동 가능성, 그리고 서버 재시작 시에도 파일이 유지되는 장점이 있습니다.

### **Q: 대용량 파일 업로드는 어떻게 처리했나요?**
A: Multer를 사용해 메모리에 임시 저장 후 S3로 직접 업로드하는 방식을 택했습니다. 파일 크기는 5MB로 제한하고, UUID를 활용해 파일명 충돌을 방지했습니다. 향후에는 멀티파트 업로드나 프리사인드 URL을 고려할 수 있습니다.

### **Q: 데이터베이스 연결 풀은 어떻게 관리했나요?**
A: TypeORM의 기본 연결 풀 설정을 사용했으며, PostgreSQL의 특성상 동시 연결 수를 적절히 관리했습니다. Supabase를 사용해 연결 풀링이 자동으로 최적화되도록 했습니다.

### **Q: API 응답 시간 최적화는 어떻게 했나요?**
A: 불필요한 데이터 로딩을 방지하기 위해 `select` 옵션으로 필요한 필드만 조회하고, 페이지네이션으로 대량 데이터 로딩을 방지했습니다. 또한 관계 데이터는 필요한 경우에만 JOIN으로 가져왔습니다.

---

### **🛠 소셜 로그인 및 OAuth**

### **Q: 소셜 로그인은 어떻게 구현했나요?**
A: Passport.js의 Strategy 패턴을 활용하여 Google과 Kakao OAuth를 구현했습니다. 각 제공자별로 다른 응답 데이터를 공통 User 엔티티로 매핑하는 로직을 작성했습니다.

### **Q: 소셜 로그인과 로컬 계정 연동은 어떻게 처리했나요?**
A: 이메일을 기준으로 기존 계정을 확인합니다. 동일한 이메일의 로컬 계정이 있으면 소셜 정보를 업데이트하고, 없으면 신규 사용자로 처리합니다. `provider`와 `providerId` 필드로 소셜 계정을 식별합니다.

### **Q: 소셜 회원가입 플로우는 어떻게 구성했나요?**
A: 2단계로 구성했습니다. 1단계는 OAuth 인증으로 기본 정보를 받고, 기존 사용자면 바로 로그인, 신규 사용자면 `isNewUser: true`를 반환합니다. 2단계에서 사용자가 추가 정보(userId, username)를 입력하면 회원가입을 완료합니다.

---

### **📧 이메일 및 외부 서비스**

### **Q: 이메일 인증은 어떻게 구현했나요?**
A: Gmail SMTP를 사용해 Nodemailer로 인증번호를 발송합니다. 6자리 랜덤 코드를 생성하여 메모리에 5분간 저장하고, 사용자가 입력한 코드와 비교해 인증을 완료합니다. HTML 템플릿으로 사용자 친화적인 이메일을 제작했습니다.

### **Q: 이메일 발송 실패 시 처리는?**
A: try-catch로 에러를 잡아 적절한 에러 메시지를 반환합니다. 실패 시 재시도 로직은 구현하지 않았지만, 향후 Redis와 큐 시스템을 도입해 안정성을 높일 계획입니다.

### **Q: 외부 API 의존성 관리는 어떻게 했나요?**
A: 환경변수 검증을 통해 서비스 설정 상태를 확인합니다. AWS S3의 경우 설정이 없으면 경고 메시지를 출력하고 업로드 기능을 비활성화합니다. 이렇게 외부 서비스 장애가 전체 서비스에 영향을 주지 않도록 했습니다.

---

### **🧪 테스트 및 배포**

### **Q: 테스트는 어떻게 작성했나요?**
A: Jest를 사용해 단위 테스트와 E2E 테스트를 작성했습니다. Service 레이어의 비즈니스 로직과 Controller의 API 엔드포인트를 중심으로 테스트했습니다. 특히 인증, 권한 검증, 데이터 유효성 검사에 집중했습니다.

### **Q: 배포는 어떻게 진행했나요?**
A: Render 플랫폼을 사용해 배포했습니다. GitHub과 연동하여 자동 배포 파이프라인을 구성했고, 환경변수는 Render 대시보드에서 관리합니다. 빌드 과정에서 TypeScript 컴파일과 의존성 설치가 자동으로 이루어집니다.

### **Q: 환경변수 관리는 어떻게 했나요?**
A: 개발환경은 `.env.local`, 프로덕션은 Render의 환경변수 설정을 사용합니다. 민감한 정보(JWT 시크릿, DB 패스워드, API 키)는 모두 환경변수로 관리하여 코드에 하드코딩하지 않았습니다.

### **Q: CI/CD 파이프라인은 구성했나요?**
A: 현재는 GitHub과 Render의 자동 배포만 사용하고 있지만, 향후 GitHub Actions로 테스트 자동화, 코드 품질 검사, 자동 배포 파이프라인을 구성할 계획입니다.

---

### **🤝 협업 및 프로젝트 관리**

### **Q: 코드 품질 관리는 어떻게 했나요?**
A: ESLint와 Prettier를 사용해 일관된 코드 스타일을 유지했습니다. TypeScript의 타입 시스템으로 컴파일 타임 에러를 방지하고, Swagger로 API 문서를 자동 생성해 팀 간 소통을 원활하게 했습니다.

### **Q: API 문서화는 어떻게 했나요?**
A: NestJS의 Swagger 모듈을 사용해 데코레이터 기반으로 API 문서를 자동 생성했습니다. `@ApiTags`, `@ApiOperation`, `@ApiResponse` 등을 활용해 상세한 API 명세를 작성했고, 실제 배포 환경에서 Swagger UI를 제공합니다.

### **Q: 버전 관리는 어떻게 했나요?**
A: Git을 사용하여 기능별 브랜치를 생성하고, 완성된 기능은 메인 브랜치로 머지했습니다. 커밋 메시지는 일관된 형식으로 작성하여 변경 이력을 추적하기 쉽게 했습니다.

---

### **🔮 트러블슈팅 및 문제 해결**

### **Q: 개발 중 가장 어려웠던 버그는?**
A: 대댓글 시스템에서 순환 참조 문제가 가장 까다로웠습니다. JSON 직렬화 시 무한 루프가 발생했는데, `@JsonIgnore`나 DTO 변환을 통해 해결했습니다. 또한 대댓글의 대댓글을 방지하는 비즈니스 로직도 복잡했습니다.

### **Q: 성능 문제는 어떻게 해결했나요?**
A: 초기에 N+1 쿼리 문제가 있었습니다. 게시글 목록 조회 시 각 게시글마다 작성자 정보를 따로 조회하는 문제였는데, `leftJoinAndSelect`로 한 번에 조회하도록 수정했습니다.

### **Q: 배포 후 발생한 문제가 있었나요?**
A: 환경변수 설정 누락으로 AWS S3 업로드가 실패하는 문제가 있었습니다. 이를 해결하기 위해 환경변수 검증 로직을 추가하고, 설정이 없으면 기능을 비활성화하도록 개선했습니다.

### **Q: 데이터베이스 마이그레이션 중 문제는?**
A: CASCADE DELETE 설정 시 실제 데이터가 삭제되는 문제가 있었습니다. 개발 환경에서 충분히 테스트한 후 프로덕션에 적용했고, 백업을 통해 안전장치를 마련했습니다.

---

### **💡 향후 개선사항 및 확장성**

### **Q: 이 프로젝트의 한계점은 무엇인가요?**
A: 현재는 메모리 기반의 이메일 인증코드 저장, 실시간 알림 부재, 캐싱 시스템 부족 등이 한계점입니다. 또한 이미지 리사이징, 검색 성능 최적화 등도 개선이 필요합니다.

### **Q: 확장성을 위해 어떤 개선을 계획하고 있나요?**
A: Redis 도입으로 세션 관리와 캐싱을 개선하고, WebSocket으로 실시간 알림을 구현할 계획입니다. 또한 Elasticsearch로 검색 성능을 향상시키고, Sharp로 이미지 최적화도 추가할 예정입니다.

### **Q: 마이크로서비스로 분리한다면 어떻게 할 건가요?**
A: 인증 서비스, 게시글 서비스, 파일 업로드 서비스, 알림 서비스로 분리할 수 있습니다. API Gateway로 라우팅하고, 서비스 간 통신은 HTTP API나 메시지 큐를 활용할 것입니다.

### **Q: 대용량 트래픽 처리는 어떻게 할 건가요?**
A: 로드 밸런서로 서버를 분산하고, 데이터베이스는 읽기 전용 복제본을 추가할 것입니다. Redis로 세션과 자주 조회되는 데이터를 캐싱하고, CDN으로 정적 파일 배포를 최적화할 계획입니다.

---

### **🎨 기술적 의사결정**

### **Q: TypeScript를 선택한 이유는?**
A: 타입 안정성으로 런타임 에러를 줄이고, IDE의 자동완성과 리팩토링 지원을 받을 수 있습니다. 특히 복잡한 데이터 구조와 API 인터페이스를 다룰 때 타입 시스템의 도움이 컸습니다.

### **Q: 모노레포 vs 멀티레포, 어떤 전략을 택했나요?**
A: 현재는 단일 레포지토리를 사용했지만, 프론트엔드와는 별도 레포로 분리했습니다. API 서버의 복잡성이 증가하면 도메인별로 레포를 분리하는 것도 고려할 수 있습니다.

### **Q: 상태 관리는 어떻게 했나요?**
A: 백엔드에서는 데이터베이스가 상태 저장소 역할을 하고, 세션 정보는 JWT 토큰으로 관리합니다. 임시 데이터(인증 코드 등)는 메모리에 저장하지만, 향후 Redis로 이전할 계획입니다.

---

## 🔮 향후 개선 계획

1. **Redis 캐싱**: 자주 조회되는 데이터 캐싱
2. **실시간 알림**: WebSocket을 통한 실시간 알림 시스템
3. **이미지 리사이징**: Sharp를 통한 이미지 최적화
4. **검색 엔진**: Elasticsearch 도입
5. **로그 시스템**: Winston을 통한 구조화된 로깅

---

## 💡 배운 교훈

### **기술적 학습**
- NestJS의 모듈식 아키텍처의 장점
- TypeORM을 통한 효율적인 데이터베이스 관리
- JWT 기반 인증의 보안 고려사항
- 클라우드 서비스 통합의 실무 경험

### **프로젝트 관리**
- 점진적 기능 개발의 중요성
- 마이그레이션을 통한 안전한 스키마 변경
- 테스트 코드의 중요성
- API 문서화의 필요성

이 프로젝트를 통해 **실무에서 요구되는 백엔드 개발 능력**을 종합적으로 습득했으며, 특히 **복잡한 관계형 데이터베이스 설계**와 **다양한 외부 서비스 통합** 경험을 쌓을 수 있었습니다.

---

## 🎯 면접 대비 전략 가이드

### **📋 1. 프로젝트 개요 30초 피칭 준비**

**"이 프로젝트를 간단히 소개해주세요"**라는 질문에 대비해서 **30초 엘리베이터 피치**를 준비하세요:

> "MiniBlog는 NestJS와 TypeScript로 개발한 개인 블로그 플랫폼의 RESTful API 서버입니다. 
> 
> **핵심 기능**: JWT + 소셜 로그인 인증, 대댓글 시스템, 팔로우 기능, AWS S3 파일 업로드
> 
> **기술적 도전**: 자기참조 관계를 통한 대댓글 구현, OAuth 통합, 복잡한 검색 쿼리 최적화
> 
> **성과**: 실제 배포까지 완료하여 Swagger API 문서도 확인 가능합니다."

### **🎭 2. 스토리텔링 중심 설명 전략**

코드를 외우지 말고, **문제 → 해결 → 결과** 구조로 이야기를 준비하세요:

#### **🔥 대댓글 시스템 스토리**
```
문제: "일반적인 댓글 시스템에서 대댓글 기능을 어떻게 구현할까?"

고민: "무한 중첩 vs 성능 vs 사용성을 어떻게 균형 맞출까?"

해결: "TypeORM의 자기참조 관계 + 2단계 제한 로직"
- parentId 필드로 부모-자식 관계 구현
- 대댓글에 대댓글 방지로 복잡성 제거
- @ManyToOne, @OneToMany로 양방향 관계 설정

결과: "직관적인 댓글 구조 + 성능 최적화 달성"
```

#### **🔐 JWT 보안 강화 스토리**
```
문제: "Access Token만 사용하면 보안 취약점 발생"

고민: "보안과 사용자 경험 사이의 균형점은?"

해결: "Access Token(1시간) + Refresh Token(7일) 분리"
- 짧은 만료 시간으로 보안 강화
- Refresh Token은 DB 저장으로 무효화 가능
- 별도 시크릿 키로 보안성 향상

결과: "안전하면서도 사용자 친화적인 인증 시스템"
```

### **🎨 3. 실제 데모 준비**

면접 때 **라이브 데모**를 보여주면 엄청난 임팩트를 줄 수 있어요:

#### **데모 시나리오 (5분 내)**
1. **Swagger API 문서** 실시간 시연
   - "실제 배포된 API를 보여드리겠습니다"
   - 회원가입 → 로그인 → 게시글 작성 플로우

2. **핵심 기능 라이브 테스트**
   - 소셜 로그인 (Google/Kakao)
   - 대댓글 작성
   - 파일 업로드 → S3 저장 확인

3. **데이터베이스 구조** 시각화
   - pgAdmin이나 Supabase 대시보드로 실제 테이블 관계 보여주기

#### **데모 준비 체크리스트**
- [ ] API 서버 정상 작동 확인
- [ ] Swagger 문서 접근 가능 여부
- [ ] 테스트 계정 미리 준비
- [ ] 주요 API 엔드포인트 북마크
- [ ] 에러 상황 대비 (서버 다운시 스크린샷 준비)

### **🗂 4. 핵심 질문별 대답 카드 준비**

코드를 외우는 대신 **핵심 포인트 카드**를 만드세요:

#### **기술 선택 카드**
```
Q: "왜 NestJS를 선택했나요?"
키워드: TypeScript 타입 안정성, 모듈 아키텍처, 엔터프라이즈급 기능
실제 경험: "복잡한 인증 로직을 모듈별로 분리해서 관리하기 편했어요"
```

#### **문제 해결 카드**
```
Q: "가장 어려웠던 문제는?"
키워드: 대댓글 시스템, 순환 참조, 2단계 제한
실제 해결: "JSON 직렬화 무한루프 → DTO 변환으로 해결"
```

#### **성능 최적화 카드**
```
Q: "N+1 쿼리 문제 해결?"
키워드: leftJoinAndSelect, QueryBuilder, 페이지네이션  
실제 성과: "게시글 목록 로딩 시간 70% 단축"
```

### **🎪 5. 실제 면접 시뮬레이션**

#### **Mock Interview 시나리오**
친구나 가족에게 다음 질문들을 해달라고 부탁하세요:

**Level 1 (기본)**
- "이 프로젝트를 선택한 이유는?"
- "사용한 기술 스택을 설명해주세요"
- "가장 자신있는 기능은?"

**Level 2 (심화)**  
- "대댓글 시스템을 어떻게 구현했나요?"
- "JWT 보안을 어떻게 강화했나요?"
- "데이터베이스 설계에서 고려한 점은?"

**Level 3 (응용)**
- "이 서비스에 1만명이 동시 접속한다면?"
- "마이크로서비스로 분리한다면 어떻게?"
- "이 프로젝트의 한계점과 개선방안은?"

#### **답변 연습 팁**
- **STAR 기법** 사용: Situation → Task → Action → Result
- **숫자로 구체화**: "N+1 쿼리를 해결해서 응답시간 70% 단축"
- **트레이드오프 언급**: "보안과 사용성 사이의 균형을 맞췄습니다"

### **💼 6. 포트폴리오 발표 준비**

#### **발표 구조 (10분 기준)**
1. **프로젝트 개요** (1분)
   - 목적, 주요 기능, 기술 스택

2. **핵심 기능 시연** (4분)
   - 라이브 데모 또는 스크린샷
   - 인증 → 게시글 → 댓글 플로우

3. **기술적 도전과 해결** (3분)
   - 대댓글 시스템 구현 과정
   - JWT 보안 강화 방법

4. **성과와 학습** (1분)
   - 실제 배포 달성
   - 기술적 성장 포인트

5. **향후 개선 계획** (1분)
   - Redis 캐싱, WebSocket 실시간 알림 등

#### **발표 자료 준비**
- **간단한 PPT** (5-7장): 아키텍처 다이어그램, API 구조, DB 스키마
- **라이브 데모**: Swagger API 실행
- **코드 스니펫**: 핵심 로직 2-3개만 선별

### **🎤 7. 면접관별 맞춤 전략**

#### **Technical Lead/CTO**
- **관심사**: 아키텍처, 확장성, 성능
- **강조점**: QueryBuilder 최적화, 마이그레이션 관리, 보안
- **준비**: 시스템 설계 다이어그램, 성능 개선 사례

#### **Frontend Developer**
- **관심사**: API 설계, 문서화, 협업
- **강조점**: RESTful API 원칙, Swagger 문서, 에러 처리
- **준비**: API 명세서, 실제 연동 경험

#### **Backend Developer**
- **관심사**: 코드 품질, 데이터베이스 설계, 비즈니스 로직
- **강조점**: TypeORM 활용, 복잡한 쿼리, 모듈 구조
- **준비**: 실제 코드 리뷰, 설계 패턴 적용 사례

### **📱 8. 면접 당일 실전 팁**

#### **준비물 체크리스트**
- [ ] 노트북 (데모용)
- [ ] 포트폴리오 인쇄본
- [ ] API 문서 URL 메모
- [ ] 주요 질문 답변 치트시트
- [ ] GitHub 레포지토리 URL

#### **멘탈 관리**
- **완벽하지 않아도 OK**: "모든 것을 알 필요 없다, 배우려는 자세가 중요"
- **모르면 솔직히**: "이 부분은 경험해보지 못했지만, 이렇게 학습할 계획입니다"
- **열정 어필**: "이 기능을 구현하면서 정말 재미있었어요"

#### **실전 대화 예시**
```
면접관: "코드를 다 기억하시나요?"
답변: "세부 코드는 기억나지 않지만, 핵심 로직과 설계 사상은 명확히 기억합니다. 
필요하면 언제든 GitHub에서 확인하며 설명드릴 수 있어요."

면접관: "이 부분이 잘 이해가 안 되는데..."
답변: "실제 코드를 보면서 설명드릴게요. (GitHub 또는 Swagger 열기)
이 부분이 바로 제가 말씀드린 대댓글 로직입니다."
```

### **🚀 9. 최종 점검 리스트**

#### **D-7 (일주일 전)**
- [ ] 프로젝트 전체 기능 테스트
- [ ] API 서버 정상 작동 확인
- [ ] 주요 질문 30개 답변 준비
- [ ] 포트폴리오 발표자료 완성

#### **D-3 (3일 전)**
- [ ] Mock Interview 진행
- [ ] 데모 시나리오 연습
- [ ] 답변 키워드 암기
- [ ] 프로젝트 스토리 정리

#### **D-1 (하루 전)**
- [ ] 서버 최종 점검
- [ ] 노트북 배터리 충전
- [ ] 치트시트 최종 점검
- [ ] 마음가짐 정리

### **💡 마지막 조언**

#### **기억하세요!**
1. **코드보다 사고 과정**이 더 중요합니다
2. **완성된 프로젝트**만으로도 충분히 어필됩니다  
3. **배우려는 자세**를 보여주는 것이 핵심입니다
4. **실제 서비스**를 만들었다는 것 자체가 큰 장점입니다

#### **자신감을 가지세요!**
- ✅ **실제 배포**까지 완료한 프로젝트
- ✅ **복잡한 인증 시스템** 구현
- ✅ **실무 수준의 기술 스택** 활용
- ✅ **문제 해결 경험** 다수 보유

**당신은 이미 충분히 준비되어 있습니다!** 🎉

면접은 **당신의 프로젝트를 자랑하는 시간**이라고 생각하세요. 
완벽할 필요 없고, 열정과 성장 의지만 보여주면 됩니다! 💪
